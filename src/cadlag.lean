import tactic
import topology.basic
import topology.instances.real
import order.filter.basic
import data.real.basic

noncomputable theory

open set filter classical 
open_locale classical filter topology

variables {Î± : Type*} {Î² : Type*} 
variables [topological_space Î±] [topological_space Î²] 

-- xxx How do you make a set from a list as in?
--#check {(0 : â„•), 1, 2} 

-- How can I tell Lean that first, I have preorder Î±, and later linear_order Î±, and Lean should forget about the former preorder?

-- This should be in the library, but I could not find it.
lemma union_distrib_union (A B C D : set Î±) : (A âˆ© B) âˆª (C âˆ© D) = (A âˆª C) âˆ© (A âˆª D) âˆ© (B âˆª C) âˆ© (B âˆª D) :=
begin
  rw [union_distrib_right A B (Câˆ©D), union_distrib_left A C D, union_distrib_left B C D, â† inter_assoc],
end

-- This should be in the library
--example (x y : â„) : is_open (Ioo x y) :=
--begin
--  sorry,
--end

/-
  ## This file is for defining cadlag functions and some basic properties
  i.e. functions which are right-continuous with limits from the left. We start by recalling various things for continuous functions. We will use the notion of continuity at one point. From topology/basic.lean we have

  ```
  def continuous_at (f : Î± â†’ Î²) (x : Î±) := tendsto f (ğ“ x) (ğ“ (f x))
  ```

  For the following, we need the definition of the neighborhood filter from topology/basic.lean

  ```
  @[irreducible] def nhds (a : Î±) : filter Î± := (â¨… s âˆˆ {s : set Î± | a âˆˆ s âˆ§ is_open s}, ğ“Ÿ s)
  ```

  From order/filter/basic.lean:

  `tendsto` is the generic "limit of a function" predicate.
  `tendsto f lâ‚ lâ‚‚` asserts that for every `lâ‚‚` neighborhood `a`,
  the `f`-preimage of `a` is an `lâ‚` neighborhood. 
  
  ```
  def tendsto (f : Î± â†’ Î²) (lâ‚ : filter Î±) (lâ‚‚ : filter Î²) := lâ‚.map f â‰¤ lâ‚‚
  ```

  Recall that a filter is the following from order/filter/basic.lean

  ```
  structure filter (Î± : Type*) :=
  (sets                   : set (set Î±))
  (univ_sets              : set.univ âˆˆ sets)
  (sets_of_superset {x y} : x âˆˆ sets â†’ x âŠ† y â†’ y âˆˆ sets)
  (inter_sets {x y}       : x âˆˆ sets â†’ y âˆˆ sets â†’ x âˆ© y âˆˆ sets)
  ```
  We will need the following filters:

  * `ğ“ x`: the filter `nhds x` of neighborhoods of a point `x`;
  * `ğ“[â‰¥] x`: the filter `nhds_within x (set.Ici x)` of right-neighborhoods of `x`;
  * `ğ“[<] x`: the filter `nhds_within x (set.Iio x)` of punctured left-neighborhoods of `x`;

  Here, the nhds x and nhds_within x s filters are

  ```
  @[irreducible] def nhds (a : Î±) : filter Î± := (â¨… s âˆˆ {s : set Î± | a âˆˆ s âˆ§ is_open s}, ğ“Ÿ s)

  def nhds_within (a : Î±) (s : set Î±) : filter Î± := ğ“ a âŠ“ ğ“Ÿ s
  ```
  
  where (from order and data/set/intervals/basic.lean)

  ```
  def principal (s : set Î±) : filter Î± :=
  { sets             := {t | s âŠ† t},
  univ_sets        := subset_univ s,
  sets_of_superset := Î» x y hx, subset.trans hx,
  inter_sets       := Î» x y, subset_inter }  

  set.Iio a = {x : Î± | x < a}
  set.Ici a = {x : Î± | a â‰¤ x}

  ```
  While ğ“ x is the usual neighborhood filter (i.e. the set of all neighborhoods of x), let us look at ğ“[â‰¥] x and ğ“[<] x a bit more closely. First, the notation ğ“ a âŠ“ ğ“Ÿ s is for the filter generated by all intersections of sets in ğ“ a and ğ“Ÿ s. If s = [x,âŠ¤), this means that ğ“[â‰¥] x contains all neighborhoods t of x, together with right-neighborhoods of the form t âˆ© [x,âŠ¤). 
-/


def cadlag_at [preorder Î±] (f : Î± â†’ Î²) (x : Î±) := 
tendsto f (ğ“[â‰¥] x) (ğ“ (f x)) âˆ§ 
âˆƒ y : Î², tendsto f (ğ“[<] x) (ğ“ y)

lemma cadlag_at.tendsto [preorder Î±] {f : Î± â†’ Î²} {x : Î±} (h : cadlag_at f x) :
  tendsto f (ğ“[â‰¥] x) (ğ“ (f x)) âˆ§ âˆƒ y : Î², tendsto f (ğ“[<] x) (ğ“ y) :=
h

lemma cadlag_at_def [preorder Î±] {f : Î± â†’ Î²} {x : Î±} : (cadlag_at f x) â†” (((âˆ€ A âˆˆ ğ“ (f x), f â»Â¹' A âˆˆ ğ“[â‰¥] x) âˆ§ (âˆƒ y : Î², âˆ€ A âˆˆ ğ“ y, f â»Â¹' A âˆˆ ğ“[<] x))) :=
begin
  refl, 
end

-- The type of cadlag-functions Î± â†’ Î²  
structure cadlag (Î± Î² : Type*) [preorder Î±] [topological_space Î±] [topological_space Î²] := 
( to_fun : Î± â†’ Î² ) 
( cadlag : âˆ€ (x : Î±), cadlag_at to_fun x)



/-
  ## We will show that x â†¦ âŒŠxâŒ‹ is cadlag. 
  For this, we need a few lemmas on âŒŠxâŒ‹ and âŒˆxâŒ‰.
-/

example (z : â„¤) (x : â„) : z â‰¤ âŒŠxâŒ‹ â†” (z : â„) â‰¤ x :=
begin
  exact int.le_floor, 
end

lemma floor_neg_eq_neg_ceil (x : â„) : -âŒŠxâŒ‹ = âŒˆ-xâŒ‰ :=
begin
  exact int.ceil_neg.symm, 
end

lemma ceil_neg_eq_neg_floor (x : â„) : -(âŒˆxâŒ‰ : â„) = (âŒŠ-xâŒ‹ : â„) :=
begin
  rw int.floor_neg, norm_cast,  
end

lemma lt_ceil_sub_one (x : â„) : (âŒˆx-1âŒ‰ : â„) < x := 
begin
  rw â† neg_lt_neg_iff, 
  rw ceil_neg_eq_neg_floor (x-1),
  simp, rw sub_eq_neg_add, 
  rw int.floor_add_one (-x), 
  simp only [int.cast_add, int.lt_floor_add_one, int.cast_one], 
end

/-
  ## The next two lemmas will be used for proving that the GauÃŸ bracket is cadlag.
-/

lemma l1 (x : â„) : (set.Ioo (âŒˆx-1âŒ‰ : â„)) x âˆˆ (ğ“[<] x) :=
begin
  change ((set.Ioo (âŒˆx-1âŒ‰ : â„)) x) âˆˆ ğ“ x âŠ“ ğ“Ÿ (Iio x),
  rw filter.mem_inf_iff, 
  have h1 : Ioo (âŒˆx-1âŒ‰ : â„) (x+1) âˆˆ ğ“ x, 
  {
    rw mem_nhds_iff_exists_Ioo_subset,
    use (âŒˆx-1âŒ‰ : â„), use (x+1),
    exact âŸ¨ âŸ¨ lt_ceil_sub_one x, lt_add_one xâŸ© , rfl.subset âŸ©, 
  },
  have h2 : Iio x âˆˆ ğ“Ÿ (Iio x), 
  {
    exact mem_principal_self (Iio x), 
  },
  use Ioo (âŒˆx-1âŒ‰ : â„) (x+1), split, exact h1, use Iio x, split, exact h2, 
  ext y, 
  rw mem_inter_iff,
   change (âŒˆx-1âŒ‰ : â„) < y âˆ§ y < x â†” ((âŒˆx-1âŒ‰ : â„) < y âˆ§ y < (x+1)) âˆ§ y < x, 
  split, 
  {
    rintro âŸ¨ h1, h2 âŸ©, split, split; linarith, exact h2, 
  },
  {
    rintro âŸ¨ âŸ¨ h1, h2 âŸ©, h3 âŸ©, split; assumption,
  },
end

example (x y: â„) : x-1 < y â†” x < y+1 :=
begin
exact sub_lt_iff_lt_add, 
end

lemma l2 (x : â„) : (set.Ico x (âŒŠx+1âŒ‹ : â„)) âˆˆ (ğ“[â‰¥] x) :=
begin
  change (set.Ico x (âŒŠx+1âŒ‹ : â„)) âˆˆ ğ“ x âŠ“ ğ“Ÿ (Ici x),
  rw filter.mem_inf_iff, 
  have h1 : (Ioo (x-1) (âŒŠx+1âŒ‹ : â„)) âˆˆ ğ“ x, 
  {
    rw mem_nhds_iff_exists_Ioo_subset,
    use (x-1), use (âŒŠx+1âŒ‹ : â„), 
    nth_rewrite 0 int.floor_add_one,
    exact âŸ¨ âŸ¨ sub_one_lt x, int.lt_succ_floor x âŸ©, rfl.subsetâŸ©, 
  },
  have h2 : (Ici x) âˆˆ ğ“Ÿ (Ici x), 
  {
    exact mem_principal_self (Ici x), 
  },
  use (Ioo (x-1) (âŒŠx+1âŒ‹ : â„)), 
  split, 
  {
    exact h1,
  },
  {
    use (Ici x), 
    split, 
    exact h2, 
    ext y, 
    rw mem_inter_iff,
    change x â‰¤ y âˆ§ y < (âŒŠx+1âŒ‹ : â„) â†” (x-1 < y âˆ§ y < (âŒŠx+1âŒ‹ : â„)) âˆ§ (x â‰¤ y), 
    split, 
    {
      rintro âŸ¨ h1, h2 âŸ©,
      split, split; linarith, linarith, 
    },
    {
      rintro âŸ¨ âŸ¨ h1, h2 âŸ©, h3 âŸ©, 
      split; linarith, 
    },
  },
end

-- Now we show that x â†¦ âŒŠxâŒ‹ is cadlag 
example : cadlag â„ â„ :=
{
  to_fun := Î» x, (int.floor x : â„),
  cadlag := begin
    intro x, 
    rw cadlag_at_def, 
    split, 
    { 
      intros A hA, 
      have h : Ico x (âŒŠx+1âŒ‹ : â„) âŠ† (Î» (x : â„), â†‘âŒŠxâŒ‹) â»Â¹' ({âŒŠxâŒ‹} : set â„), 
      {
        intro y, 
        change xâ‰¤y âˆ§ y < (âŒŠx+1âŒ‹ : â„) â†’ (âŒŠyâŒ‹ : â„) = (âŒŠxâŒ‹ : â„), 
        rintro âŸ¨ h1, h2 âŸ©, 
        simp, 
        apply eq_of_le_of_not_lt, 
        {
          rw â† add_zero âŒŠxâŒ‹,
          change âŒŠyâŒ‹ â‰¤ âŒŠxâŒ‹ + (1 - 1),
          rw â† add_sub_assoc, 
          rw int.le_sub_one_iff,
          rw â† int.floor_add_one,
          exact int.floor_lt.mpr h2,
        },
        rw not_lt, exact int.floor_mono h1,
      },
      apply filter.sets_of_superset,
      apply l2 x, 
      have h1 : (Î» (x : â„), (âŒŠxâŒ‹ : â„) ) â»Â¹' ({â†‘âŒŠxâŒ‹} : set â„)  âŠ† (Î» (x : â„), (âŒŠxâŒ‹ : â„) ) â»Â¹' A, 
      have h2 : ({âŒŠxâŒ‹} : set â„) âŠ† A, intros a ha, cases ha, exact mem_of_mem_nhds hA,
      exact preimage_mono h2, 
      exact subset.trans h h1, 
    },
    {
      use (âŒˆx-1âŒ‰ : â„), 
      intros A hA,  
      apply filter.sets_of_superset,
      apply l1 x,
--      intro y, 
      have h : Ioo (âŒˆx-1âŒ‰ : â„) x âŠ† (Î» (x : â„), â†‘âŒŠxâŒ‹) â»Â¹' ({âŒˆx-1âŒ‰} : set â„), 
      {
        let z := (âŒˆx-1âŒ‰ : â„¤), 
        have h : z = âŒˆx-1âŒ‰, refl, 
        rw â† h, 
        intro y, dsimp, 
        rintro âŸ¨h1, h2âŸ©,
        rw eq_iff_le_not_lt, 
        split, rw h, 
        norm_cast, 
        rw int.ceil_sub_one,
        rw int.le_sub_one_iff,
        have h3 : (âŒŠyâŒ‹ : â„) â‰¤ y, exact int.floor_le y,
        have h4 : x â‰¤ (âŒˆxâŒ‰ : â„), exact int.le_ceil x,
        have h5 : (âŒŠyâŒ‹ : â„) < (âŒˆxâŒ‰ : â„),
        calc 
          (âŒŠyâŒ‹ : â„) â‰¤ y : by {apply h3,} 
            ... < x : by {apply h2,}
            ... â‰¤ (âŒˆxâŒ‰ : â„) : by {exact h4},
        norm_cast at h5, exact h5, 
        rw push_neg.not_lt_eq, rw h, 
        rw h at h1,  
        rw â† int.le_floor, simp, 
        rw int.ceil_sub_one at h1, 
        have h4 : (âŒˆxâŒ‰ : â„) < y+1, rw â†  sub_lt_iff_lt_add, 
        norm_cast at h1, 
        norm_cast, exact h1, 
        rw â† int.floor_add_one, 
        rw int.le_floor, exact le_of_lt h4, 
      },
      have h2 : ({âŒˆx-1âŒ‰} : set â„) âŠ† A, 
      {
        intros a ha, cases ha, exact mem_of_mem_nhds hA,
      },
        apply subset.trans h (preimage_mono h2),
    },
  end
}

example (A B: set â„) (f: â„â†’ â„) : (A âŠ† B) â†’ fâ»Â¹' A âŠ†  fâ»Â¹' (B) := 
begin
  exact preimage_mono,
end

/-
  Now, we want to prove that every continuous function is cadlag. It is convenient to work with filters, since the next three results hold. 
-/

lemma N_le_Nge [preorder Î±] (x : Î±) : ğ“[â‰¥] x â‰¤ ğ“ x := 
begin
  rw filter.le_def, intros S hS,
  have h3 : S âˆˆ ((ğ“ x) âŠ“ (ğ“Ÿ (set.Ici x))), exact mem_inf_of_left hS, 
  cases h3 with T hT, cases hT with hT h5, cases h5 with U hU, cases hU with hU h6, 
  use S, refine âŸ¨ hS, _ âŸ©, 
  use set.univ, split, rw filter.mem_principal at *, exact (Ici x).subset_univ, simp only [eq_self_iff_true, set.inter_univ],
end

lemma N_le_Nlt [preorder Î±] (x : Î±) : ğ“[<] x â‰¤ ğ“ x := 
begin
  rw filter.le_def, intros S hS,
  have h3 : S âˆˆ ((ğ“ x) âŠ“ (ğ“Ÿ (set.Iio x))), exact mem_inf_of_left hS, 
  cases h3 with T hT, cases hT with hT h5, cases h5 with U hU, cases hU with hU h6, 
  use S, refine âŸ¨ hS, _ âŸ©, 
  use set.univ, split, rw filter.mem_principal at *, exact (Iio x).subset_univ,
  tidy,
end

lemma N_eq_Nlt_cap_Nge [preorder Î±] (x : Î±) : ((set.Ici x) âˆª (set.Iio x) âˆˆ (ğ“ x)) â†’ ğ“ x = (ğ“[<] x) âŠ” (ğ“[â‰¥] x) := 
begin
  intro h,
  ext S, 
  rw filter.mem_sup, 
  split, 
  {
    intro hS, 
    split, 
    {revert hS S, rw â† filter.le_def, exact N_le_Nlt x,},
    {revert hS S, rw â† filter.le_def, exact N_le_Nge x,}
  },
  {
    rintro âŸ¨ h1, h2 âŸ©, 
    have h3 : S âˆˆ ((ğ“ x) âŠ“ (ğ“Ÿ (set.Ici x))), { exact h2,},
    have h4 : S âˆˆ ((ğ“ x) âŠ“ (ğ“Ÿ (set.Iio x))), { exact h1,}, 
    rw (filter.mem_inf_iff) at h3, 
    rw (filter.mem_inf_iff) at h4, 
    cases h3 with T hT, cases hT with hT h5, cases h5 with U hU, cases hU with hU h6, 
    cases h4 with V hV, cases hV with hV h7, cases h7 with W hW, cases hW with hW h8, 
    rw filter.mem_principal at *, 
    clear h1 h2, 
    have h1 : T âˆ© Ici x âŠ† S, 
    {
      rw h6, exact inter_subset_inter_right T hU,
    },
    have h2 : V âˆ© Iio x âŠ† S, 
    {
      rw h8, exact inter_subset_inter_right V hW,
    },
    have h3 : (T âˆª V) âˆ© (T âˆª Iio x) âˆ© (Ici x âˆª V) âˆ© (Ici x âˆª Iio x) âŠ† S, 
    {
      rw â† union_distrib_union T (Ici x) V (Iio x),
      exact union_subset h1 h2, 
--    rw â† union_distrib_left (Ici x) V (Iio x),
    },
    apply filter.mem_of_superset _ h3,
    apply filter.inter_mem, 
    apply filter.inter_mem, 
    apply filter.inter_mem, 
    {
      apply filter.mem_of_superset hT, exact subset_union_left T V, },
    {
      apply filter.mem_of_superset hT, exact subset_union_left T (Iio x), },
    {
      apply filter.mem_of_superset hV, exact (Ici x).subset_union_right V, },
    {
      exact h,},
  }
end

-- A composition of cadlag functions is cadlag

-- xxx

/-
### Connections to continuous functions
The following is proved: Every function which is continuous at x is also cadlag at x, and if a cadlag function has f x as its left limit, (and some additional property holds, which is always true for linearly ordered sets) it is continuous at x. 
-/

example (x : Î±) (S T : set Î±) : xâˆˆS â†’ SâŠ†T â†’xâˆˆ T :=
begin
  exact mem_of_mem_of_subset, 
end

lemma cadlag_continuous_at [preorder Î±] (f : Î± â†’ Î²) (x : Î±) : continuous_at f x â†’ ((cadlag_at f x) âˆ§ (tendsto f (ğ“[<] x) (ğ“ (f x)))) :=
begin
  intro cont, 
  split, 
  {
    rw continuous_at_def at cont,      
    rw cadlag_at_def,
    split,
    {
      intros A h,
      specialize cont A h,
      apply set.mem_of_subset_of_mem (N_le_Nge x) cont, 
    },
    {
      use f x, 
      intros A h,
      specialize cont A h,
      apply set.mem_of_subset_of_mem (N_le_Nlt x) cont, 
    },
  },
  rw continuous_at_def at cont,      
  rw tendsto_def, 
  intros A h,
  specialize cont A h,
  apply set.mem_of_subset_of_mem (N_le_Nlt x) cont, 
end

theorem cadlag_continuous_at_iff [preorder Î±] (f : Î± â†’ Î²) (x : Î±) : ((set.Ici x) âˆª (set.Iio x) âˆˆ (ğ“ x)) â†’ (continuous_at f x â†” ((cadlag_at f x) âˆ§ (tendsto f (ğ“[<] x) (ğ“ (f x))))) :=
begin
  intro h, 
  split,
  {
    exact cadlag_continuous_at f x, 
  },
  {
    rintro âŸ¨ h1, h2 âŸ©, 
    change tendsto f (ğ“ x) (ğ“ (f x)),
    have h3 : tendsto f (ğ“[Ici x] x) (ğ“ (f x)), exact h1.1,
    rw N_eq_Nlt_cap_Nge x h, 
    exact tendsto.sup h2 h3, 
  },
end

lemma l3 [linear_order Î±] {x : Î±}  : set.univ = (set.Ici x) âˆª (set.Iio x) :=
begin
  ext y, 
  have h : y<x âˆ¨ x â‰¤ y, exact lt_or_le y x,
  split, 
  { 
    intro h1, clear h1, 
    rw set.mem_union, 
    simp, exact or.swap h, 
  },
  { 
    intro h, 
    triv, 
  }
end

/-
  ### Composition of continuous and cadlag is cadlag. 
-/


/-
  ### Coercions
  Since continuous âŠ† cadlag, there should be a coercion from continuous to cadlag functions.  xxx
-/
