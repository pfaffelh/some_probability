import tactic
import topology.basic
import topology.instances.real
import order.filter.basic
import data.real.basic

noncomputable theory

open set filter classical 
open_locale classical filter topology

variables {α : Type*} {β : Type*} 
variables [topological_space α] [topological_space β] 

-- xxx How do you make a set from a list as in?
--#check {(0 : ℕ), 1, 2} 

-- How can I tell Lean that first, I have preorder α, and later linear_order α, and Lean should forget about the former preorder?

-- This should be in the library, but I could not find it.
lemma union_distrib_union (A B C D : set α) : (A ∩ B) ∪ (C ∩ D) = (A ∪ C) ∩ (A ∪ D) ∩ (B ∪ C) ∩ (B ∪ D) :=
begin
  rw [union_distrib_right A B (C∩D), union_distrib_left A C D, union_distrib_left B C D, ← inter_assoc],
end

-- This should be in the library
--example (x y : ℝ) : is_open (Ioo x y) :=
--begin
--  sorry,
--end

/-
  ## This file is for defining cadlag functions and some basic properties
  i.e. functions which are right-continuous with limits from the left. We start by recalling various things for continuous functions. We will use the notion of continuity at one point. From topology/basic.lean we have

  ```
  def continuous_at (f : α → β) (x : α) := tendsto f (𝓝 x) (𝓝 (f x))
  ```

  For the following, we need the definition of the neighborhood filter from topology/basic.lean

  ```
  @[irreducible] def nhds (a : α) : filter α := (⨅ s ∈ {s : set α | a ∈ s ∧ is_open s}, 𝓟 s)
  ```

  From order/filter/basic.lean:

  `tendsto` is the generic "limit of a function" predicate.
  `tendsto f l₁ l₂` asserts that for every `l₂` neighborhood `a`,
  the `f`-preimage of `a` is an `l₁` neighborhood. 
  
  ```
  def tendsto (f : α → β) (l₁ : filter α) (l₂ : filter β) := l₁.map f ≤ l₂
  ```

  Recall that a filter is the following from order/filter/basic.lean

  ```
  structure filter (α : Type*) :=
  (sets                   : set (set α))
  (univ_sets              : set.univ ∈ sets)
  (sets_of_superset {x y} : x ∈ sets → x ⊆ y → y ∈ sets)
  (inter_sets {x y}       : x ∈ sets → y ∈ sets → x ∩ y ∈ sets)
  ```
  We will need the following filters:

  * `𝓝 x`: the filter `nhds x` of neighborhoods of a point `x`;
  * `𝓝[≥] x`: the filter `nhds_within x (set.Ici x)` of right-neighborhoods of `x`;
  * `𝓝[<] x`: the filter `nhds_within x (set.Iio x)` of punctured left-neighborhoods of `x`;

  Here, the nhds x and nhds_within x s filters are

  ```
  @[irreducible] def nhds (a : α) : filter α := (⨅ s ∈ {s : set α | a ∈ s ∧ is_open s}, 𝓟 s)

  def nhds_within (a : α) (s : set α) : filter α := 𝓝 a ⊓ 𝓟 s
  ```
  
  where (from order and data/set/intervals/basic.lean)

  ```
  def principal (s : set α) : filter α :=
  { sets             := {t | s ⊆ t},
  univ_sets        := subset_univ s,
  sets_of_superset := λ x y hx, subset.trans hx,
  inter_sets       := λ x y, subset_inter }  

  set.Iio a = {x : α | x < a}
  set.Ici a = {x : α | a ≤ x}

  ```
  While 𝓝 x is the usual neighborhood filter (i.e. the set of all neighborhoods of x), let us look at 𝓝[≥] x and 𝓝[<] x a bit more closely. First, the notation 𝓝 a ⊓ 𝓟 s is for the filter generated by all intersections of sets in 𝓝 a and 𝓟 s. If s = [x,⊤), this means that 𝓝[≥] x contains all neighborhoods t of x, together with right-neighborhoods of the form t ∩ [x,⊤). 
-/


def cadlag_at [preorder α] (f : α → β) (x : α) := 
tendsto f (𝓝[≥] x) (𝓝 (f x)) ∧ 
∃ y : β, tendsto f (𝓝[<] x) (𝓝 y)

lemma cadlag_at.tendsto [preorder α] {f : α → β} {x : α} (h : cadlag_at f x) :
  tendsto f (𝓝[≥] x) (𝓝 (f x)) ∧ ∃ y : β, tendsto f (𝓝[<] x) (𝓝 y) :=
h

lemma cadlag_at_def [preorder α] {f : α → β} {x : α} : (cadlag_at f x) ↔ (((∀ A ∈ 𝓝 (f x), f ⁻¹' A ∈ 𝓝[≥] x) ∧ (∃ y : β, ∀ A ∈ 𝓝 y, f ⁻¹' A ∈ 𝓝[<] x))) :=
begin
  refl, 
end

-- The type of cadlag-functions α → β  
structure cadlag (α β : Type*) [preorder α] [topological_space α] [topological_space β] := 
( to_fun : α → β ) 
( cadlag : ∀ (x : α), cadlag_at to_fun x)



/-
  ## We will show that x ↦ ⌊x⌋ is cadlag. 
  For this, we need a few lemmas on ⌊x⌋ and ⌈x⌉.
-/

example (z : ℤ) (x : ℝ) : z ≤ ⌊x⌋ ↔ (z : ℝ) ≤ x :=
begin
  exact int.le_floor, 
end

lemma floor_neg_eq_neg_ceil (x : ℝ) : -⌊x⌋ = ⌈-x⌉ :=
begin
  exact int.ceil_neg.symm, 
end

lemma ceil_neg_eq_neg_floor (x : ℝ) : -(⌈x⌉ : ℝ) = (⌊-x⌋ : ℝ) :=
begin
  rw int.floor_neg, norm_cast,  
end

lemma lt_ceil_sub_one (x : ℝ) : (⌈x-1⌉ : ℝ) < x := 
begin
  rw ← neg_lt_neg_iff, 
  rw ceil_neg_eq_neg_floor (x-1),
  simp, rw sub_eq_neg_add, 
  rw int.floor_add_one (-x), 
  simp only [int.cast_add, int.lt_floor_add_one, int.cast_one], 
end

/-
  ## The next two lemmas will be used for proving that the Gauß bracket is cadlag.
-/

lemma l1 (x : ℝ) : (set.Ioo (⌈x-1⌉ : ℝ)) x ∈ (𝓝[<] x) :=
begin
  change ((set.Ioo (⌈x-1⌉ : ℝ)) x) ∈ 𝓝 x ⊓ 𝓟 (Iio x),
  rw filter.mem_inf_iff, 
  have h1 : Ioo (⌈x-1⌉ : ℝ) (x+1) ∈ 𝓝 x, 
  {
    rw mem_nhds_iff_exists_Ioo_subset,
    use (⌈x-1⌉ : ℝ), use (x+1),
    exact ⟨ ⟨ lt_ceil_sub_one x, lt_add_one x⟩ , rfl.subset ⟩, 
  },
  have h2 : Iio x ∈ 𝓟 (Iio x), 
  {
    exact mem_principal_self (Iio x), 
  },
  use Ioo (⌈x-1⌉ : ℝ) (x+1), split, exact h1, use Iio x, split, exact h2, 
  ext y, 
  rw mem_inter_iff,
   change (⌈x-1⌉ : ℝ) < y ∧ y < x ↔ ((⌈x-1⌉ : ℝ) < y ∧ y < (x+1)) ∧ y < x, 
  split, 
  {
    rintro ⟨ h1, h2 ⟩, split, split; linarith, exact h2, 
  },
  {
    rintro ⟨ ⟨ h1, h2 ⟩, h3 ⟩, split; assumption,
  },
end

example (x y: ℝ) : x-1 < y ↔ x < y+1 :=
begin
exact sub_lt_iff_lt_add, 
end

lemma l2 (x : ℝ) : (set.Ico x (⌊x+1⌋ : ℝ)) ∈ (𝓝[≥] x) :=
begin
  change (set.Ico x (⌊x+1⌋ : ℝ)) ∈ 𝓝 x ⊓ 𝓟 (Ici x),
  rw filter.mem_inf_iff, 
  have h1 : (Ioo (x-1) (⌊x+1⌋ : ℝ)) ∈ 𝓝 x, 
  {
    rw mem_nhds_iff_exists_Ioo_subset,
    use (x-1), use (⌊x+1⌋ : ℝ), 
    nth_rewrite 0 int.floor_add_one,
    exact ⟨ ⟨ sub_one_lt x, int.lt_succ_floor x ⟩, rfl.subset⟩, 
  },
  have h2 : (Ici x) ∈ 𝓟 (Ici x), 
  {
    exact mem_principal_self (Ici x), 
  },
  use (Ioo (x-1) (⌊x+1⌋ : ℝ)), 
  split, 
  {
    exact h1,
  },
  {
    use (Ici x), 
    split, 
    exact h2, 
    ext y, 
    rw mem_inter_iff,
    change x ≤ y ∧ y < (⌊x+1⌋ : ℝ) ↔ (x-1 < y ∧ y < (⌊x+1⌋ : ℝ)) ∧ (x ≤ y), 
    split, 
    {
      rintro ⟨ h1, h2 ⟩,
      split, split; linarith, linarith, 
    },
    {
      rintro ⟨ ⟨ h1, h2 ⟩, h3 ⟩, 
      split; linarith, 
    },
  },
end

-- Now we show that x ↦ ⌊x⌋ is cadlag 
example : cadlag ℝ ℝ :=
{
  to_fun := λ x, (int.floor x : ℝ),
  cadlag := begin
    intro x, 
    rw cadlag_at_def, 
    split, 
    { 
      intros A hA, 
      have h : Ico x (⌊x+1⌋ : ℝ) ⊆ (λ (x : ℝ), ↑⌊x⌋) ⁻¹' ({⌊x⌋} : set ℝ), 
      {
        intro y, 
        change x≤y ∧ y < (⌊x+1⌋ : ℝ) → (⌊y⌋ : ℝ) = (⌊x⌋ : ℝ), 
        rintro ⟨ h1, h2 ⟩, 
        simp, 
        apply eq_of_le_of_not_lt, 
        {
          rw ← add_zero ⌊x⌋,
          change ⌊y⌋ ≤ ⌊x⌋ + (1 - 1),
          rw ← add_sub_assoc, 
          rw int.le_sub_one_iff,
          rw ← int.floor_add_one,
          exact int.floor_lt.mpr h2,
        },
        rw not_lt, exact int.floor_mono h1,
      },
      apply filter.sets_of_superset,
      apply l2 x, 
      have h1 : (λ (x : ℝ), (⌊x⌋ : ℝ) ) ⁻¹' ({↑⌊x⌋} : set ℝ)  ⊆ (λ (x : ℝ), (⌊x⌋ : ℝ) ) ⁻¹' A, 
      have h2 : ({⌊x⌋} : set ℝ) ⊆ A, intros a ha, cases ha, exact mem_of_mem_nhds hA,
      exact preimage_mono h2, 
      exact subset.trans h h1, 
    },
    {
      use (⌈x-1⌉ : ℝ), 
      intros A hA,  
      apply filter.sets_of_superset,
      apply l1 x,
--      intro y, 
      have h : Ioo (⌈x-1⌉ : ℝ) x ⊆ (λ (x : ℝ), ↑⌊x⌋) ⁻¹' ({⌈x-1⌉} : set ℝ), 
      {
        let z := (⌈x-1⌉ : ℤ), 
        have h : z = ⌈x-1⌉, refl, 
        rw ← h, 
        intro y, dsimp, 
        rintro ⟨h1, h2⟩,
        rw eq_iff_le_not_lt, 
        split, rw h, 
        norm_cast, 
        rw int.ceil_sub_one,
        rw int.le_sub_one_iff,
        have h3 : (⌊y⌋ : ℝ) ≤ y, exact int.floor_le y,
        have h4 : x ≤ (⌈x⌉ : ℝ), exact int.le_ceil x,
        have h5 : (⌊y⌋ : ℝ) < (⌈x⌉ : ℝ),
        calc 
          (⌊y⌋ : ℝ) ≤ y : by {apply h3,} 
            ... < x : by {apply h2,}
            ... ≤ (⌈x⌉ : ℝ) : by {exact h4},
        norm_cast at h5, exact h5, 
        rw push_neg.not_lt_eq, rw h, 
        rw h at h1,  
        rw ← int.le_floor, simp, 
        rw int.ceil_sub_one at h1, 
        have h4 : (⌈x⌉ : ℝ) < y+1, rw ←  sub_lt_iff_lt_add, 
        norm_cast at h1, 
        norm_cast, exact h1, 
        rw ← int.floor_add_one, 
        rw int.le_floor, exact le_of_lt h4, 
      },
      have h2 : ({⌈x-1⌉} : set ℝ) ⊆ A, 
      {
        intros a ha, cases ha, exact mem_of_mem_nhds hA,
      },
        apply subset.trans h (preimage_mono h2),
    },
  end
}

example (A B: set ℝ) (f: ℝ→ ℝ) : (A ⊆ B) → f⁻¹' A ⊆  f⁻¹' (B) := 
begin
  exact preimage_mono,
end

/-
  Now, we want to prove that every continuous function is cadlag. It is convenient to work with filters, since the next three results hold. 
-/

lemma N_le_Nge [preorder α] (x : α) : 𝓝[≥] x ≤ 𝓝 x := 
begin
  rw filter.le_def, intros S hS,
  have h3 : S ∈ ((𝓝 x) ⊓ (𝓟 (set.Ici x))), exact mem_inf_of_left hS, 
  cases h3 with T hT, cases hT with hT h5, cases h5 with U hU, cases hU with hU h6, 
  use S, refine ⟨ hS, _ ⟩, 
  use set.univ, split, rw filter.mem_principal at *, exact (Ici x).subset_univ, simp only [eq_self_iff_true, set.inter_univ],
end

lemma N_le_Nlt [preorder α] (x : α) : 𝓝[<] x ≤ 𝓝 x := 
begin
  rw filter.le_def, intros S hS,
  have h3 : S ∈ ((𝓝 x) ⊓ (𝓟 (set.Iio x))), exact mem_inf_of_left hS, 
  cases h3 with T hT, cases hT with hT h5, cases h5 with U hU, cases hU with hU h6, 
  use S, refine ⟨ hS, _ ⟩, 
  use set.univ, split, rw filter.mem_principal at *, exact (Iio x).subset_univ,
  tidy,
end

lemma N_eq_Nlt_cap_Nge [preorder α] (x : α) : ((set.Ici x) ∪ (set.Iio x) ∈ (𝓝 x)) → 𝓝 x = (𝓝[<] x) ⊔ (𝓝[≥] x) := 
begin
  intro h,
  ext S, 
  rw filter.mem_sup, 
  split, 
  {
    intro hS, 
    split, 
    {revert hS S, rw ← filter.le_def, exact N_le_Nlt x,},
    {revert hS S, rw ← filter.le_def, exact N_le_Nge x,}
  },
  {
    rintro ⟨ h1, h2 ⟩, 
    have h3 : S ∈ ((𝓝 x) ⊓ (𝓟 (set.Ici x))), { exact h2,},
    have h4 : S ∈ ((𝓝 x) ⊓ (𝓟 (set.Iio x))), { exact h1,}, 
    rw (filter.mem_inf_iff) at h3, 
    rw (filter.mem_inf_iff) at h4, 
    cases h3 with T hT, cases hT with hT h5, cases h5 with U hU, cases hU with hU h6, 
    cases h4 with V hV, cases hV with hV h7, cases h7 with W hW, cases hW with hW h8, 
    rw filter.mem_principal at *, 
    clear h1 h2, 
    have h1 : T ∩ Ici x ⊆ S, 
    {
      rw h6, exact inter_subset_inter_right T hU,
    },
    have h2 : V ∩ Iio x ⊆ S, 
    {
      rw h8, exact inter_subset_inter_right V hW,
    },
    have h3 : (T ∪ V) ∩ (T ∪ Iio x) ∩ (Ici x ∪ V) ∩ (Ici x ∪ Iio x) ⊆ S, 
    {
      rw ← union_distrib_union T (Ici x) V (Iio x),
      exact union_subset h1 h2, 
--    rw ← union_distrib_left (Ici x) V (Iio x),
    },
    apply filter.mem_of_superset _ h3,
    apply filter.inter_mem, 
    apply filter.inter_mem, 
    apply filter.inter_mem, 
    {
      apply filter.mem_of_superset hT, exact subset_union_left T V, },
    {
      apply filter.mem_of_superset hT, exact subset_union_left T (Iio x), },
    {
      apply filter.mem_of_superset hV, exact (Ici x).subset_union_right V, },
    {
      exact h,},
  }
end

-- A composition of cadlag functions is cadlag

-- xxx

/-
### Connections to continuous functions
The following is proved: Every function which is continuous at x is also cadlag at x, and if a cadlag function has f x as its left limit, (and some additional property holds, which is always true for linearly ordered sets) it is continuous at x. 
-/

example (x : α) (S T : set α) : x∈S → S⊆T →x∈ T :=
begin
  exact mem_of_mem_of_subset, 
end

lemma cadlag_continuous_at [preorder α] (f : α → β) (x : α) : continuous_at f x → ((cadlag_at f x) ∧ (tendsto f (𝓝[<] x) (𝓝 (f x)))) :=
begin
  intro cont, 
  split, 
  {
    rw continuous_at_def at cont,      
    rw cadlag_at_def,
    split,
    {
      intros A h,
      specialize cont A h,
      apply set.mem_of_subset_of_mem (N_le_Nge x) cont, 
    },
    {
      use f x, 
      intros A h,
      specialize cont A h,
      apply set.mem_of_subset_of_mem (N_le_Nlt x) cont, 
    },
  },
  rw continuous_at_def at cont,      
  rw tendsto_def, 
  intros A h,
  specialize cont A h,
  apply set.mem_of_subset_of_mem (N_le_Nlt x) cont, 
end

theorem cadlag_continuous_at_iff [preorder α] (f : α → β) (x : α) : ((set.Ici x) ∪ (set.Iio x) ∈ (𝓝 x)) → (continuous_at f x ↔ ((cadlag_at f x) ∧ (tendsto f (𝓝[<] x) (𝓝 (f x))))) :=
begin
  intro h, 
  split,
  {
    exact cadlag_continuous_at f x, 
  },
  {
    rintro ⟨ h1, h2 ⟩, 
    change tendsto f (𝓝 x) (𝓝 (f x)),
    have h3 : tendsto f (𝓝[Ici x] x) (𝓝 (f x)), exact h1.1,
    rw N_eq_Nlt_cap_Nge x h, 
    exact tendsto.sup h2 h3, 
  },
end

lemma l3 [linear_order α] {x : α}  : set.univ = (set.Ici x) ∪ (set.Iio x) :=
begin
  ext y, 
  have h : y<x ∨ x ≤ y, exact lt_or_le y x,
  split, 
  { 
    intro h1, clear h1, 
    rw set.mem_union, 
    simp, exact or.swap h, 
  },
  { 
    intro h, 
    triv, 
  }
end

/-
  ### Composition of continuous and cadlag is cadlag. 
-/


/-
  ### Coercions
  Since continuous ⊆ cadlag, there should be a coercion from continuous to cadlag functions.  xxx
-/
